/*
you must have already install the midi and the FastLED library
also you need the LiquidCrystal_I2C
https://github.com/FortySevenEffects/arduino_midi_library/
https://github.com/FastLED/FastLED
https://github.com/johnrickman/LiquidCrystal_I2C
if your lcd is not working change LiquidCrystal_I2C lcd(0x27,16,2); to LiquidCrystal_I2C lcd(0x3F,16,2);
*/
#define USE_GPIO_INIT  0
#define USE_SPI_MIDI   1
const char Instr000[] PROGMEM = "Acoustic Grand Piano";
const char Instr001[] PROGMEM = "Bright Acoustic Piano";
const char Instr002[] PROGMEM = "Electric Grand Piano";
const char Instr003[] PROGMEM = "Honky-tonk Piano";
const char Instr004[] PROGMEM = "Electric Piano 1";
const char Instr005[] PROGMEM = "Electric Piano 2";
const char Instr006[] PROGMEM = "Harpsichord";
const char Instr007[] PROGMEM = "Clavinet";
// Chromatic Percussion Family:
const char Instr008[] PROGMEM = "Celesta";
const char Instr009[] PROGMEM = "Glockenspiel";
const char Instr010[] PROGMEM = "Music Box";
const char Instr011[] PROGMEM = "Vibraphone";
const char Instr012[] PROGMEM = "Marimba";
const char Instr013[] PROGMEM = "Xylophone";
const char Instr014[] PROGMEM = "Tubular Bells";
const char Instr015[] PROGMEM = "Dulcimer";
// Organ Family:
const char Instr016[] PROGMEM = "Drawbar Organ";
const char Instr017[] PROGMEM = "Percussive Organ";
const char Instr018[] PROGMEM = "Rock Organ";
const char Instr019[] PROGMEM = "Church Organ";
const char Instr020[] PROGMEM = "Reed Organ";
const char Instr021[] PROGMEM = "Accordion";
const char Instr022[] PROGMEM = "Harmonica";
const char Instr023[] PROGMEM = "Tango Accordion";
// Guitar Family:
const char Instr024[] PROGMEM = "Acoustic Guitar (nylon)";
const char Instr025[] PROGMEM = "Acoustic Guitar (steel)";
const char Instr026[] PROGMEM = "Electric Guitar (jazz)";
const char Instr027[] PROGMEM = "Electric Guitar (clean)";
const char Instr028[] PROGMEM = "Electric Guitar (muted)";
const char Instr029[] PROGMEM = "Overdriven Guitar";
const char Instr030[] PROGMEM = "Distortion Guitar";
const char Instr031[] PROGMEM = "Guitar harmonics";
// Bass Family:
const char Instr032[] PROGMEM = "Acoustic Bass";
const char Instr033[] PROGMEM = "Electric Bass (finger)";
const char Instr034[] PROGMEM = "Electric Bass (pick)";
const char Instr035[] PROGMEM = "Fretless Bass";
const char Instr036[] PROGMEM = "Slap Bass 1";
const char Instr037[] PROGMEM = "Slap Bass 2";
const char Instr038[] PROGMEM = "Synth Bass 1";
const char Instr039[] PROGMEM = "Synth Bass 2";
// Strings Family:
const char Instr040[] PROGMEM = "Violin";
const char Instr041[] PROGMEM = "Viola";
const char Instr042[] PROGMEM = "Cello";
const char Instr043[] PROGMEM = "Contrabass";
const char Instr044[] PROGMEM = "Tremolo Strings";
const char Instr045[] PROGMEM = "Pizzicato Strings";
const char Instr046[] PROGMEM = "Orchestral Harp";
const char Instr047[] PROGMEM = "Timpani";
// Ensemble Family:
const char Instr048[] PROGMEM = "String Ensemble 1";
const char Instr049[] PROGMEM = "String Ensemble 2";
const char Instr050[] PROGMEM = "Synth Strings 1";
const char Instr051[] PROGMEM = "Synth Strings 2";
const char Instr052[] PROGMEM = "Choir Aahs";
const char Instr053[] PROGMEM = "Voice Oohs";
const char Instr054[] PROGMEM = "Synth Voice";
const char Instr055[] PROGMEM = "Orchestra Hit";
// Brass Family:
const char Instr056[] PROGMEM = "Trumpet";
const char Instr057[] PROGMEM = "Trombone";
const char Instr058[] PROGMEM = "Tuba";
const char Instr059[] PROGMEM = "Muted Trumpet";
const char Instr060[] PROGMEM = "French Horn";
const char Instr061[] PROGMEM = "Brass Section";
const char Instr062[] PROGMEM = "Synth Brass 1";
const char Instr063[] PROGMEM = "Synth Brass 2";
// Reed Family:
const char Instr064[] PROGMEM = "Soprano Sax";
const char Instr065[] PROGMEM = "Alto Sax";
const char Instr066[] PROGMEM = "Tenor Sax";
const char Instr067[] PROGMEM = "Baritone Sax";
const char Instr068[] PROGMEM = "Oboe";
const char Instr069[] PROGMEM = "English Horn";
const char Instr070[] PROGMEM = "Bassoon";
const char Instr071[] PROGMEM = "Clarinet";
// Pipe Family:
const char Instr072[] PROGMEM = "Piccolo";
const char Instr073[] PROGMEM = "Flute";
const char Instr074[] PROGMEM = "Recorder";
const char Instr075[] PROGMEM = "Pan Flute";
const char Instr076[] PROGMEM = "Blown Bottle";
const char Instr077[] PROGMEM = "Shakuhachi";
const char Instr078[] PROGMEM = "Whistle";
const char Instr079[] PROGMEM = "Ocarina";
// Synth Lead Family:
const char Instr080[] PROGMEM = "Lead 1 (square)";
const char Instr081[] PROGMEM = "Lead 2 (sawtooth)";
const char Instr082[] PROGMEM = "Lead 3 (calliope)";
const char Instr083[] PROGMEM = "Lead 4 (chiff)";
const char Instr084[] PROGMEM = "Lead 5 (charang)";
const char Instr085[] PROGMEM = "Lead 6 (voice)";
const char Instr086[] PROGMEM = "Lead 7 (fifths)";
const char Instr087[] PROGMEM = "Lead 8 (bass)";
// Synth Pad Family:
const char Instr088[] PROGMEM = "Pad 1 (new age)";
const char Instr089[] PROGMEM = "Pad 2 (warm)";
const char Instr090[] PROGMEM = "Pad 3 (polysynth)";
const char Instr091[] PROGMEM = "Pad 4 (choir)";
const char Instr092[] PROGMEM = "Pad 5 (bowed)";
const char Instr093[] PROGMEM = "Pad 6 (metallic)";
const char Instr094[] PROGMEM = "Pad 7 (halo)";
const char Instr095[] PROGMEM = "Pad 8 (sweep)";
// Synth Effects Family:
const char Instr096[] PROGMEM = "FX 1 (rain)";
const char Instr097[] PROGMEM = "FX 2 (soundtrack)";
const char Instr098[] PROGMEM = "FX 3 (crystal)";
const char Instr099[] PROGMEM = "FX 4 (atmosphere)";
const char Instr100[] PROGMEM = "FX 5 (brightness)";
const char Instr101[] PROGMEM = "FX 6 (goblins)";
const char Instr102[] PROGMEM = "FX 7 (echoes)";
const char Instr103[] PROGMEM = "FX 8 (scifi)";
// Ethnic Family:
const char Instr104[] PROGMEM = "Sitar";
const char Instr105[] PROGMEM = "Banjo";
const char Instr106[] PROGMEM = "Shamisen";
const char Instr107[] PROGMEM = "Koto";
const char Instr108[] PROGMEM = "Kalimba";
const char Instr109[] PROGMEM = "Bag pipe";
const char Instr110[] PROGMEM = "Fiddle";
const char Instr111[] PROGMEM = "Shanai";
// Percussive Family:
const char Instr112[] PROGMEM = "Tinkle Bell";
const char Instr113[] PROGMEM = "Agogo";
const char Instr114[] PROGMEM = "Steel Drums";
const char Instr115[] PROGMEM = "Woodblock";
const char Instr116[] PROGMEM = "Taiko Drum";
const char Instr117[] PROGMEM = "Melodic Tom";
const char Instr118[] PROGMEM = "Synth Drum";
const char Instr119[] PROGMEM = "Reverse Cymbal";
// Sound Effects Family:
const char Instr120[] PROGMEM = "Guitar Fret Noise";
const char Instr121[] PROGMEM = "Breath Noise";
const char Instr122[] PROGMEM = "Seashore";
const char Instr123[] PROGMEM = "Bird Tweet";
const char Instr124[] PROGMEM = "Telephone Ring";
const char Instr125[] PROGMEM = "Helicopter";
const char Instr126[] PROGMEM = "Applause";
const char Instr127[] PROGMEM = "Gunshot";

const char Instr128[] PROGMEM = "PercussionInstrument";
bool lcduse;
const char* const InstrBank1[] PROGMEM = 
{ Instr000, Instr001, Instr002, Instr003, Instr004, Instr005, Instr006, Instr007, Instr008, Instr009, Instr010, Instr011, Instr012, Instr013, Instr014, Instr015, 
  Instr016, Instr017, Instr018, Instr019, Instr020, Instr021, Instr022, Instr023, Instr024, Instr025, Instr026, Instr027, Instr028, Instr029, Instr030, Instr031, 
  Instr032, Instr033, Instr034, Instr035, Instr036, Instr037, Instr038, Instr039, Instr040, Instr041, Instr042, Instr043, Instr044, Instr045, Instr046, Instr047, 
  Instr048, Instr049, Instr050, Instr051, Instr052, Instr053, Instr054, Instr055, Instr056, Instr057, Instr058, Instr059, Instr060, Instr061, Instr062, Instr063, 
  Instr064, Instr065, Instr066, Instr067, Instr068, Instr069, Instr070, Instr071, Instr072, Instr073, Instr074, Instr075, Instr076, Instr077, Instr078, Instr079, 
  Instr080, Instr081, Instr082, Instr083, Instr084, Instr085, Instr086, Instr087, Instr088, Instr089, Instr090, Instr091, Instr092, Instr093, Instr094, Instr095, 
  Instr096, Instr097, Instr098, Instr099, Instr100, Instr101, Instr102, Instr103, Instr104, Instr105, Instr106, Instr107, Instr108, Instr109, Instr110, Instr111, 
  Instr112, Instr113, Instr114, Instr115, Instr116, Instr117, Instr118, Instr119, Instr120, Instr121, Instr122, Instr123, Instr124, Instr125, Instr126, Instr127, Instr128
};
#define USE_PATCH_INIT  !USE_GPIO_INIT
#define USE_SERIAL_MIDI !USE_SPI_INIT
#define USE_SPI         (USE_SPI_MIDI||USE_PATCH_INIT)

#if USE_SPI
#include <SPI.h>
#endif
#if USE_SERIAL_MIDI
#include <SoftwareSerial.h>
SoftwareSerial midiSerial(2,3); // Soft TX on 3, RX not used (2 is an input anyway, for VS_DREQ)
#endif

#if USE_SPI
#define VS_XCS    6 // Control Chip Select Pin (for accessing SPI Control/Status registers)
#define VS_XDCS   7 // Data Chip Select / BSYNC Pin
#define VS_DREQ   2 // Data Request Pin: Player asks for more data
#endif
#if USE_GPIO_INIT
#define VS_GPIO1  4  // Mode selection (0 = file / 1 = real time MIDI)
#endif

#define VS_RESET  8 //Reset is active low

#if USE_PATCH_INIT
//Write to VS10xx register
//SCI: Data transfers are always 16bit. When a new SCI operation comes in 
//DREQ goes low. We then have to wait for DREQ to go high again.
//XCS should be low for the full duration of operation.
void VSWriteRegister(unsigned char addressbyte, unsigned char highbyte, unsigned char lowbyte){
  while(!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating IC is available
  digitalWrite(VS_XCS, LOW); //Select control

  //SCI consists of instruction byte, address byte, and 16-bit data word.
  SPI.transfer(0x02); //Write instruction
  SPI.transfer(addressbyte);
  SPI.transfer(highbyte);
  SPI.transfer(lowbyte);
  while(!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating command is complete
  digitalWrite(VS_XCS, HIGH); //Deselect Control
}

//
// Plugin to put VS10XX into realtime MIDI mode
// Originally from http://www.vlsi.fi/fileadmin/software/VS10XX/vs1053b-rtmidistart.zip
// Permission to reproduce here granted by VLSI solution.
//
const unsigned short sVS1053b_Realtime_MIDI_Plugin[28] = { /* Compressed plugin */
  0x0007, 0x0001, 0x8050, 0x0006, 0x0014, 0x0030, 0x0715, 0xb080, /*    0 */
  0x3400, 0x0007, 0x9255, 0x3d00, 0x0024, 0x0030, 0x0295, 0x6890, /*    8 */
  0x3400, 0x0030, 0x0495, 0x3d00, 0x0024, 0x2908, 0x4d40, 0x0030, /*   10 */
  0x0200, 0x000a, 0x0001, 0x0050,
};

void VSLoadUserCode(void) {
  int i = 0;

  while (i<sizeof(sVS1053b_Realtime_MIDI_Plugin)/sizeof(sVS1053b_Realtime_MIDI_Plugin[0])) {
    unsigned short addr, n, val;
    addr = sVS1053b_Realtime_MIDI_Plugin[i++];
    n = sVS1053b_Realtime_MIDI_Plugin[i++];
    while (n--) {
      val = sVS1053b_Realtime_MIDI_Plugin[i++];
      VSWriteRegister(addr, val >> 8, val & 0xFF);
    }
  }
}
#include "FastLED.h"

// How many leds in your strip?
#define NUM_LEDS 15 

// For led chips like Neopixels, which have a data line, ground, and power, you just
// need to define DATA_PIN.  For led chipsets that are SPI based (four wires - data, clock,
// ground, and power), like the LPD8806, define both DATA_PIN and CLOCK_PIN
#define DATA_PIN 9
#define CLOCK_PIN 13

// Define the array of leds
CRGB leds[NUM_LEDS];
#endif
#include <MIDI.h>
MIDI_CREATE_DEFAULT_INSTANCE();
#include <Wire.h> 
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x27,16,2);  // if your lcd is not working change the address to 0x3F
void setup()
{
  LEDS.addLeds<WS2812,DATA_PIN,RGB>(leds,NUM_LEDS);
  LEDS.setBrightness(84);
  pinMode(4,INPUT_PULLUP);
 lcduse=1-digitalRead(4);
 lcd.init();                      // initialize the lcd 
 // Print a message to the LCD.
 lcd.backlight();
  lcd.print("VS1053b synth");
  delay(1000);
 if(lcduse==1){
 char buffer1[24];
    strcpy_P(buffer1, (char*)pgm_read_word(&(InstrBank1[0]))); 
   // lcd.clear();
    lcd.setCursor(0,0);
    lcd.print(buffer1);
    lcd.setCursor(0,1);
    lcd.print("Channel: 1");
 }

#if USE_SPI
  pinMode(VS_DREQ, INPUT);
  pinMode(VS_XCS, OUTPUT);
  pinMode(VS_XDCS, OUTPUT);
  digitalWrite(VS_XCS, HIGH); //Deselect Control
  digitalWrite(VS_XDCS, HIGH); //Deselect Data
#endif
#if USE_SERIAL_MIDI
  midiSerial.begin(31250);
#endif

  pinMode(VS_RESET, OUTPUT);

   MIDI.begin(MIDI_CHANNEL_OMNI); //Use serial for debugging 
 

  //Initialize VS1053 chip 
  digitalWrite(VS_RESET, LOW); //Put VS1053 into hardware reset

#if USE_SPI
  //Setup SPI for VS1053
  SPI.begin();
  SPI.setBitOrder(MSBFIRST);
  SPI.setDataMode(SPI_MODE0);

  //From page 12 of datasheet, max SCI reads are CLKI/7. Input clock is 12.288MHz. 
  //Internal clock multiplier is 1.0x after power up. 
  //Therefore, max SPI speed is 1.75MHz. We will use 1MHz to be safe.
  SPI.setClockDivider(SPI_CLOCK_DIV16); //Set SPI bus speed to 1MHz (16MHz / 16 = 1MHz)
  SPI.transfer(0xFF); //Throw a dummy byte at the bus
#endif

  delayMicroseconds(1);
  digitalWrite(VS_RESET, HIGH); //Bring up VS1053
  
#if USE_PATCH_INIT
  VSLoadUserCode();
#else
  pinMode(VS_GPIO1, OUTPUT);
  digitalWrite(VS_GPIO1, HIGH);  // Enable real time MIDI mode
#endif
}

void sendMIDI(byte data)
{
#if USE_SPI_MIDI
  SPI.transfer(0);
  SPI.transfer(data);
#else
  midiSerial.write(data);
#endif
}

//Plays a MIDI note. Doesn't check to see that cmd is greater than 127, or that data values are less than 127
void talkMIDI(byte cmd, byte data1, byte data2) {
#if USE_SPI_MIDI
  //
  // Wait for chip to be ready (Unlikely to be an issue with real time MIDI)
  //
  while (!digitalRead(VS_DREQ))
    ;
  digitalWrite(VS_XDCS, LOW);
#endif
  sendMIDI(cmd);
  //Some commands only have one data byte. All cmds less than 0xBn have 2 data bytes 
  //(sort of: http://253.ccarh.org/handout/midiprotocol/)
  if( (cmd & 0xF0) <= 0xB0 || (cmd & 0xF0) >= 0xE0) {
    sendMIDI(data1);
    sendMIDI(data2);
  } else {
    sendMIDI(data1);
  }

#if USE_SPI_MIDI
  digitalWrite(VS_XDCS, HIGH);
#endif
}

//Send a MIDI note-on message.  Like pressing a piano key
//channel ranges from 0-15
void noteOn(byte channel, byte note, byte attack_velocity) {
  talkMIDI( (0x90 | channel), note, attack_velocity);
}

//Send a MIDI note-off message.  Like releasing a piano key
void noteOff(byte channel, byte note, byte release_velocity) {
  talkMIDI( (0x80 | channel), note, release_velocity);
}
byte prev;
byte nnow;
byte chan;

  byte r2;
byte g2;
byte b2;

uint32_t Wheel(byte WheelPos) {
 if(WheelPos < 85) {
   r2=WheelPos * 3;
   g2=255 - WheelPos * 3;
   b2=0;
  } else if(WheelPos < 170) {
   WheelPos -= 85;
   r2=255 - WheelPos * 3;
   g2=0;
   b2=WheelPos * 3;
  } else {
   WheelPos -= 170;
   r2=0; 
   g2=WheelPos * 3;
   b2=255 - WheelPos * 3;
  }}
void loop() {
  char buffer1[24];
    if (MIDI.read())                // Is there a MIDI message incoming ?
    {
  talkMIDI(MIDI.getType()+MIDI.getChannel()-1, MIDI.getData1(), MIDI.getData2());
  if(MIDI.getType()==0xC0){nnow= MIDI.getData1(); chan=MIDI.getChannel();}
  if(MIDI.getType()==0x90&&MIDI.getData2()!=0&&lcduse==1){Wheel(MIDI.getData2()*2); leds[MIDI.getChannel()-1] = CRGB(r2,g2,b2); FastLED.show(); }
  if(MIDI.getType()==0x80&&lcduse==1||MIDI.getType()==0x90&&MIDI.getData2()==0&&lcduse==1){leds[MIDI.getChannel()-1] = CRGB(0,0,0); FastLED.show(); }
    }
    if(nnow!=prev&&lcduse==1){
      if(chan==10){
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("Percussion:");
    lcd.setCursor(12,0);
    lcd.print(nnow);
    lcd.setCursor(0,1);
    lcd.print("Channel:");
    lcd.setCursor(9,1);
    lcd.print(chan);
    prev=nnow;
      }
      else{
    strcpy_P(buffer1, (char*)pgm_read_word(&(InstrBank1[nnow]))); 
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print(buffer1);
    lcd.setCursor(0,1);
    lcd.print("Channel:");
    lcd.setCursor(9,1);
    lcd.print(chan);
    prev=nnow;
      }
    }
}
